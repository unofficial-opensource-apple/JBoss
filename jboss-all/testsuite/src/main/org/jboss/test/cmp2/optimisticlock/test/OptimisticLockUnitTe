
/*
 * JBoss, the OpenSource J2EE webOS
 *
 * Distributable under LGPL license.
 * See terms of license at gnu.org.
 *
 */

package org.jboss.test.cmp2.optimisticlock.test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import javax.rmi.PortableRemoteObject;

import org.apache.log4j.Category;
import junit.framework.Test;
import junit.framework.TestCase;
import org.jboss.test.JBossTestCase;
import net.sourceforge.junitejb.EJBTestCase;
import org.jboss.test.cmp2.optimisticlock.interfaces.FacadeHome;
import org.jboss.test.cmp2.optimisticlock.interfaces.Facade;

/**
 * This class tests JDBCOptimistic lock with different strategies
 * by starting two concurrent threads that trying to modify the same entity bean.
 * First client starts transaction and sleeps for some time while the other
 * client makes it's modification. Then the first client wakes up and fail to commit.
 *
 * @author <a href="mailto:aloubyansky@hotmail.com">Alex Loubyansky</a>
 * @version 1.0
 */
public class OptimisticLockUnitTestCase
   extends JBossTestCase
{
   // Constants -------------------------------------
   private static final String ENTITY_GROUP_LOCKING = "local/EntityGroupLocking";
   private static final String ENTITY_MODIFIED_LOCKING = "local/EntityModifiedLocking";
   private static final String ENTITY_READ_LOCKING = "local/EntityReadLocking";
   private static final String ENTITY_VERSION_LOCKING = "local/EntityVersionLocking";
   private static final String ENTITY_TIMESTAMP_LOCKING = "local/EntityTimestampLocking";
   private static final String ENTITY_KEYGEN_LOCKING = "local/EntityKeyGeneratorLocking";

   // Attributes ------------------------------------
   private FacadeHome facadeHome;
   /** entity primary key value */
   private Integer integerField = new Integer(1);
   /** initial stringField value */
   private String stringField = "initial value";
   /** the value client1 will use to update stringField */
   private String client1StringField = "client1 was here";
   /** the value client2 will use to update stringField */
   private String client2StringField = "client2 was here";

   // Constructor -----------------------------------
   public OptimisticLockUnitTestCase(String name)
   {
      super(name);
   }

   // TestCase overrides ----------------------------
   public static Test suite() throws Exception
   {
      return getDeploySetup(OptimisticLockUnitTestCase.class, "cmp2-optimisticlock.jar");
   }

   // Tests -----------------------------------------
   public void testFieldGroupStrategy() throws Exception
   {
      performScenario(ENTITY_GROUP_LOCKING, 1500, 0);
   }

   public void testModifiedStrategy() throws Exception
   {
      performScenario(ENTITY_MODIFIED_LOCKING, 1500, 0);
   }

   public void testReadStrategy() throws Exception
   {
      performScenario(ENTITY_READ_LOCKING, 1500, 0);
   }

   public void testVersionStrategy() throws Exception
   {
      performScenario(ENTITY_VERSION_LOCKING, 1500, 0);
   }

   public void testTimestampStrategy() throws Exception
   {
      // increase the second delay as the second client could modify
      // entity at the time the first client locked the timestamp column value
      performScenario(ENTITY_TIMESTAMP_LOCKING, 2500, 1000);
   }

   public void testKeyGeneratorStrategy() throws Exception
   {
      performScenario(ENTITY_KEYGEN_LOCKING, 1500, 0);
   }

   // Private ---------------------------------------
   private void performScenario(String entityJndiName, int delay1, int delay2)
      throws Exception
   {
      Facade facade = getFacadeHome().create();
      facade.createCmpEntity(
         entityJndiName, integerField, stringField, new java.util.Date()
      );

      // client1 should start first and finish last
      Client client1 = new Client(
         integerField, client1StringField, entityJndiName, delay1
      );
      Client client2 = new Client(
         integerField, client2StringField, entityJndiName, delay2
      );

      // start client1
      client1.start();

      // make sure client1 is the first
      try {
         Thread.sleep(500);
      } catch(InterruptedException ie) { }

      // start client2
      client2.start();

      // wait for clients to finish
      while(client1.isAlive() || client2.isAlive())
      {
         try {
            Thread.sleep(600);
         } catch(InterruptedException ignore) { }
      }

      assertTrue("Client1 failed to update stringField "
         + "because Client2 was first", client1.getFailed());
   }

   private FacadeHome getFacadeHome()
      throws NamingException
   {
      if(facadeHome == null)
      {
         InitialContext ic = new InitialContext();
         Object ref = ic.lookup(FacadeHome.JNDI_NAME);
         facadeHome = (FacadeHome)PortableRemoteObject.narrow(
            ref, FacadeHome.class
         );
      }
      return facadeHome;
   }

   // Inner -----------------------------------------
   public class Client
      extends Thread
   {
      // Attributes ---------------------------------
      private Integer integerField;
      private String stringField;
      private String entityJndiName;
      private long delay;
      private boolean failed = false;

      // Constructor --------------------------------
      public Client(Integer integerField,
                    String stringField,
                    String entityJndiName,
                    long delay)
      {
         this.integerField = integerField;
         this.stringField = stringField;
         this.entityJndiName = entityJndiName;
         this.delay = delay;
      }

      // Public -------------------------------------
      public boolean getFailed()
      {
         return failed;
      }

      // Thread overrides ---------------------------
      public void run()
      {
         System.out.println(this.getName() + "> run(): starting update "
            + "integerField=" + integerField
            + "; stringField=" + stringField
            + "; entityJndiName=" + entityJndiName
            + "; delay=" + delay
         );


         try
         {
            Facade facade = getFacadeHome().create();
            facade.delayedUpdateStringField(
               entityJndiName, integerField, stringField, delay
            );
         }
         catch(Exception e)
         {
            failed = true;
         }

         System.out.println(this.getName() + "> run(): finished");
      }
   }
}
